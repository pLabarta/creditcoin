<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Creditcoin Dev Guide</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/building.html"><strong aria-hidden="true">1.1.</strong> Building from source</a></li><li class="chapter-item expanded "><a href="getting-started/running-a-node.html"><strong aria-hidden="true">1.2.</strong> Running a development node</a></li><li class="chapter-item expanded "><a href="getting-started/observing-your-chain.html"><strong aria-hidden="true">1.3.</strong> Observing your development chain</a></li><li class="chapter-item expanded "><a href="getting-started/substrate-resources.html"><strong aria-hidden="true">1.4.</strong> Learning about substrate</a></li></ol></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Architecture and Repo Layout</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/client.html"><strong aria-hidden="true">2.1.</strong> Client</a></li><li class="chapter-item expanded "><a href="architecture/runtime/runtime.html"><strong aria-hidden="true">2.2.</strong> Runtime</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="architecture/runtime/pallet-creditcoin.html"><strong aria-hidden="true">2.2.1.</strong> Creditcoin pallet</a></li><li class="chapter-item expanded "><a href="architecture/runtime/pallet-difficulty.html"><strong aria-hidden="true">2.2.2.</strong> Difficulty pallet</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Creditcoin Dev Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>To get started hacking on creditcoin, you'll want to be able to build and run a development node from source.</p>
<p>First you'll need to get set up <a href="./getting-started/building.html">building from source</a>. After that, take a look at <a href="./getting-started/running-a-node.html">running a development chain</a>
with the <code>creditcoin-node</code> you just built from source. Once you have your development chain up and running
<a href="./getting-started/observing-your-chain.html">explore your chain</a></p>
<p>and take a look at the various storage items, extrinsics, and other developer tools available in the polkadotJS explorer.</p>
<p>Once you've taken a look around, you can start <a href="./getting-started/substrate-resources.html">learning more about substrate</a> and blockchains in general.</p>
<p>When you're ready to start hacking on creditcoin, get a sense of the <a href="./architecture.html">architecture and repo layout</a> to see all of the pieces
we work with and how they fit together.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-the-creditcoin-node-from-source"><a class="header" href="#building-the-creditcoin-node-from-source">Building the <code>creditcoin-node</code> from source</a></h1>
<p><em>Note on development platforms: development is easiest from a unix environment (whether that be linux, macOS, or WSL). It should be possible to
develop natively in windows but you'll most likely be on your own.</em></p>
<h2 id="build-prerequisites"><a class="header" href="#build-prerequisites">Build prerequisites</a></h2>
<h3 id="install-the-rust-toolchain"><a class="header" href="#install-the-rust-toolchain">Install the Rust toolchain</a></h3>
<p>You'll need a working Rust installation, if you don't have one already available (NOTE: you'll want to install and manage your Rust toolchain with <code>rustup</code>,
not by installing your distro's <code>rust</code> package which will most likely be too old).</p>
<p>For the installation you can refer to <a href="https://www.rust-lang.org/tools/install">these instructions</a>.</p>
<p>Once you have a working rust installation, you'll need to add the <code>wasm32-unknown-unknown</code> target and install the nightly toolchain</p>
<pre><code class="language-bash">rustup update
rustup toolchain install nightly
rustup target add wasm32-unknown-unknown --nightly
</code></pre>
<p>Note: So that you don't have to specify the toolchain every build, you can set <code>nightly</code> as your default toolchain while working on creditcoin.</p>
<p>You can also check <a href="getting-started//ci/env">./ci/env</a> for the toolchain being used in our CI in case you run into issues with newer version before we notice them.</p>
<pre><code class="language-bash"># set nightly as default for your creditcoin checkout
rustup override set nightly
</code></pre>
<h3 id="system-build-dependencies"><a class="header" href="#system-build-dependencies">System build dependencies</a></h3>
<p>You'll need a few system dependencies (some extra dependencies may be required depending on the platform, but
all platforms require the following):</p>
<ul>
<li>Clang</li>
<li>Protobuf compiler</li>
<li>CMake</li>
<li>OpenSSL</li>
</ul>
<h4 id="macos-setup"><a class="header" href="#macos-setup">MacOS setup</a></h4>
<p>macOS comes with a suitable <code>clang</code> installation, so you don't need to worry about it.
For installing the remaining dependencies the easiest method is using <a href="https://brew.sh">homebrew</a>.</p>
<p>Assuming you have homebrew installed, you can run the following in the terminal:</p>
<pre><code class="language-bash">brew update
brew install cmake openssl protobuf
</code></pre>
<h4 id="ubuntudebian-setup"><a class="header" href="#ubuntudebian-setup">Ubuntu/Debian setup</a></h4>
<p>Run the following in the terminal</p>
<pre><code class="language-bash">sudo apt update
# May prompt for location information
sudo apt install -y cmake pkg-config libssl-dev git build-essential clang libclang-dev curl protobuf-compiler
</code></pre>
<h2 id="clone-the-creditcoin-repo"><a class="header" href="#clone-the-creditcoin-repo">Clone the creditcoin repo</a></h2>
<p>If you haven't already, you'll want to clone the creditcoin repo and <code>cd</code> into the resulting clone:</p>
<pre><code class="language-bash">git clone https://github.com/gluwa/creditcoin
cd creditcoin
</code></pre>
<h2 id="build-the-creditcoin-node"><a class="header" href="#build-the-creditcoin-node">Build the <code>creditcoin-node</code></a></h2>
<p>You should now be able to build the <code>creditcoin-node</code>. It's a normal Rust project, so you can perform a release build
(99% of the time you'll want a release build, a debug build is often too slow to be useful).</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>Assuming the build completed without errors, you should have a <code>creditcoin-node</code> binary in your target directory.
To make sure the binary works, you can try taking a look at the <code>--help</code>:</p>
<pre><code class="language-bash">./target/release/creditcoin-node --help
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-a-creditcoin-node"><a class="header" href="#running-a-creditcoin-node">Running a Creditcoin node</a></h1>
<h2 id="running-a-development-node"><a class="header" href="#running-a-development-node">Running a development node</a></h2>
<p>Now that you've built a <code>creditcoin-node</code> from source, you can get a minimal development node running with:</p>
<pre><code class="language-bash">./target/release/creditcoin-node --dev --mining-key 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY --mining-threads 1
</code></pre>
<p>The node should start running and produce output similar to below:</p>
<pre><code class="language-plaintext">2023-01-05 19:54:53 Creditcoin Node
2023-01-05 19:54:53 ‚úåÔ∏è  version 2.211.2-e972d650ee6
2023-01-05 19:54:53 ‚ù§Ô∏è  by Gluwa Inc.:Nathan Whitaker &lt;nathan.whitaker@gluwa.com&gt;, 2017-2023
2023-01-05 19:54:53 üìã Chain specification: Development
2023-01-05 19:54:53 üè∑  Node name: cute-geese-8080
2023-01-05 19:54:53 üë§ Role: AUTHORITY
2023-01-05 19:54:53 üíæ Database: RocksDb at /var/folders/jw/4ykz4cmj7q7fkjp9t6pv6z7h0000gn/T/substrateLol6Jy/chains/dev/db/full
2023-01-05 19:54:53 ‚õì  Native runtime: creditcoin-node-212 (creditcoin-node-0.tx10.au1)
2023-01-05 19:54:53 üî® Initializing Genesis block/state (state: 0x652a‚Ä¶44ab, header-hash: 0x6dd1‚Ä¶2b4e)
2023-01-05 19:54:53 Using default protocol ID &quot;sup&quot; because none is configured in the chain specs
2023-01-05 19:54:53 üè∑  Local node identity is: 12D3KooWCMzU5LdWErgqjLZxVSwveDjGrRQ7q4zcuycjHocPCNDs
2023-01-05 19:54:53 üíª Operating system: macos
2023-01-05 19:54:53 üíª CPU architecture: aarch64
2023-01-05 19:54:53 üì¶ Highest known block at #0
2023-01-05 19:54:53 Running JSON-RPC HTTP server: addr=127.0.0.1:9933, allowed origins=None
2023-01-05 19:54:53 Running JSON-RPC WS server: addr=127.0.0.1:9944, allowed origins=None
2023-01-05 19:54:53 „ÄΩÔ∏è Prometheus exporter started at 127.0.0.1:9615
2023-01-05 19:54:58 üí§ Idle (0 peers), best: #0 (0x6dd1‚Ä¶2b4e), finalized #0 (0x6dd1‚Ä¶2b4e), ‚¨á 0 ‚¨Ü 0
2023-01-05 19:55:03 üí§ Idle (0 peers), best: #0 (0x6dd1‚Ä¶2b4e), finalized #0 (0x6dd1‚Ä¶2b4e), ‚¨á 0 ‚¨Ü 0
2023-01-05 19:55:03 üôå Starting consensus session on top of parent 0x6dd1a66ff1b0b6482f8da72b829420f10eafa99a6fda25c9f8992fa381d92b4e
2023-01-05 19:55:03 üéÅ Prepared block for proposing at 1 (0 ms) [hash: 0x1293ab00b882c45fc6ebf312992cc127e596d1350b3d2202f3d48dd64ac7d88b; parent_hash: 0x6dd1‚Ä¶2b4e; extrinsics (1): [0x93be‚Ä¶9e86]]
2023-01-05 19:55:04 üôå Starting consensus session on top of parent 0x1029bb84cb03783d8b927e8b98b48f65b04f0afdb06abc08f2428503b5078572
2023-01-05 19:55:04 ‚úÖ Successfully mined block on top of: 0x6dd1‚Ä¶2b4e
2023-01-05 19:55:04 ‚ú® Imported #1 (0x1029‚Ä¶8572)
2023-01-05 19:55:04 üéÅ Prepared block for proposing at 2 (0 ms) [hash: 0x07fbf7a2b55b414e4e208a0b75e25735a0855455660667c2834bfcb2e7a2d74f; parent_hash: 0x1029‚Ä¶8572; extrinsics (1): [0x51fb‚Ä¶557f]]
</code></pre>
<p>By default this is a temporary chain, so when you stop your development node the chain will be wiped out. If you want a local development
chain that is persistent, you can use the <code>local</code> chain specification:</p>
<pre><code class="language-bash">./target/release/creditcoin-node --chain local --validator --mining-key 5GrwvaEF5zXb26Fz9rcQpDWS57CtERHpNehXCPcNoHGKutQY --mining-threads 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="observing-the-development-chain"><a class="header" href="#observing-the-development-chain">Observing the development chain</a></h1>
<p>With a node up and running, it's often useful to inspect the status of the development chain. The Polkadot explorer is
the easiest way to take a look at a live chain.</p>
<p>In your browser, open up <a href="https://polkadot.js.org/apps">the Polkadot explorer</a>. Now you'll want to point the explorer at your running
development node. In the top left corner, there's a menu accessible by clocking the name of the current chain:</p>
<p><img src="getting-started/../img/explorer-chain-dropdown.png" alt="Chain selection menu" /></p>
<p>In the newly opened menu, expand the <code>Development</code> section at the bottom, then select &quot;Local Node&quot;:</p>
<p><img src="getting-started/../img/local-chain-select.png" alt="&quot;Local Node&quot;" /></p>
<p>Finally click the Switch button at the top of the chain selection menu:
<img src="getting-started/../img/switch-chain.png" alt="&quot;Switch&quot;" /></p>
<p>The explorer should now show the chain running on your local node, and new blocks should be appearing regularly (every 5-30 seconds):</p>
<p><img src="getting-started/../img/local-node-explorer.png" alt="It should look something like this" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="learning-about-substrate"><a class="header" href="#learning-about-substrate">Learning about substrate</a></h1>
<p>The Creditcoin blockchain is built on the <a href="https://docs.substrate.io/">substrate framework</a>, which provides most of the underlying
blockchain functionality (P2P networking, block production, RPC server, storage, etc.). This allows us
to focus on the functionality specific to creditcoin and additionally we benefit from
existing tooling developed for the polkadot/substrate ecosystem (such as the polkadot explorer, polkadotJS, telemetry, etc.).</p>
<h2 id="helpful-resources"><a class="header" href="#helpful-resources">Helpful resources</a></h2>
<p>The official substrate documentation provides a good starting point, I would recommend (at a minimum) reading through
all of the material in the <a href="https://docs.substrate.io/fundamentals/">fundamentals section</a>.</p>
<p>That should give you a rough understanding of substrate's architecture, and how the pieces fit together.</p>
<p>For learning about FRAME and best practices, the <a href="https://github.com/paritytech/substrate">substrate repository</a> has a bunch of pallets of varying complexity that serve as good reference points.
For starters, the <a href="https://github.com/paritytech/substrate/tree/polkadot-v0.9.32/frame/sudo">sudo pallet</a> is fairly small and
digestible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="architecture-and-repo-layout"><a class="header" href="#architecture-and-repo-layout">Architecture and repo layout</a></h1>
<p>This chapter is intended to give a sense of the individual pieces in a creditcoin node, how
the pieces fit together, and where the code for those pieces live. For the most part,
this will talk about the components a creditcoin developer actually interacts with
and won't go in-depth into underlying components (like substrate internals).</p>
<p>The main components of a <code>creditcoin-node</code> are the <a href="./architecture/client.html">client</a> and
the <a href="./architecture/runtime/runtime.html">runtime</a>. The user / node operator interacts with the client
through either the CLI or RPC calls. The client calls into the runtime as needed
using an executor (part of substrate). The runtime is composed using the FRAME
modular framework, which enables reusable modules called <em>pallets</em>. The majority
of creditcoin's business logic is split across a variety of pallets.</p>
<pre class="mermaid">%%{init: {'theme': 'dark'}}%%
graph BT
    CLI --&gt; Client
    RPC[RPC Call] --&gt; Client
    Client --&gt;|Executor| Runtime
    Runtime --&gt;|FRAME| Pallets
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client--outer-node"><a class="header" href="#client--outer-node">Client / Outer Node</a></h1>
<p>This is the part that handles all interactions with the host machine and outside world.
By extension, the client is the primary point of interaction for node operators - whether that be
through the CLI or by performing RPC calls.
The code for the client lives in the <a href="https://github.com/gluwa/creditcoin/tree/dev/node"><code>node</code> directory</a>.</p>
<h2 id="cli"><a class="header" href="#cli">CLI</a></h2>
<p>The command line interface you interact with as a user (the <code>creditcoin-node</code> binary) uses
<a href="https://docs.rs/clap">clap</a>, similar to many Rust projects.
The actual interface is defined in <a href="https://github.com/gluwa/creditcoin/tree/dev/node/src/cli.rs"><code>node/src/cli.rs</code></a>. It consists of the
CLI options and subcommands.</p>
<p>The actual parsing and execution of the CLI command occurs in <a href="https://github.com/gluwa/creditcoin/tree/dev/node/src/command.rs"><code>command.rs</code></a>.
This is the entrypoint to a creditcoin node (<code>main</code> just calls into <code>command::run</code>)
For most subcommands this means calling the appropriate implementations provided by substrate.</p>
<p>When running a node (as opposed to a subcommand), we call into the <code>service</code> module to actual construct
the client.</p>
<h2 id="service"><a class="header" href="#service">Service</a></h2>
<p>This is where we put together all of the pieces of the client - configuring storage, kicking off networking,
setting up the RPC server,
connecting to telemetry, setting up the block import pipeline (and consensus, which is part of the import pipeline), and more.
This is also the entrypoint to mining (we just spawn a bunch of threads which are tasked with mining and submitting results).</p>
<p>This code lives in <a href="https://github.com/gluwa/creditcoin/tree/dev/node/src/service.rs"><code>node/src/service.rs</code></a>.</p>
<h2 id="rpc"><a class="header" href="#rpc">RPC</a></h2>
<p>This is where we define custom RPC methods and extend the standard RPC server with our custom method handlers.
For example, we expose a custom RPC method for retrieving
your node's current hashrate so node operators can monitor their mining performance.</p>
<p>The code for extending the RPC server with custom handlers lives in <a href="https://github.com/gluwa/creditcoin/tree/dev/node/src/rpc.rs"><code>node/src/rpc.rs</code></a>. Once
you've defined your custom RPC methods and their handlers, you would need to edit this code to register your new handlers.</p>
<p>The code for <em>defining</em> new RPC methods is currently located in <a href="https://github.com/gluwa/creditcoin/tree/dev/node/rpc"><code>node/rpc</code></a>.</p>
<h2 id="consensus--pow"><a class="header" href="#consensus--pow">Consensus / PoW</a></h2>
<p>The client also contains consensus-related code. Creditcoin uses Proof of Work, which requires block authors
to generate solutions to a problem (mining) and if a &quot;good enough&quot; solution is produced then a block can be authored. The majority of the actual
consensus is implemented in substrate, so the only parts we have to worry about are providing the difficulty, verifying
a given solution, and generating solutions (mining).</p>
<h3 id="difficulty"><a class="header" href="#difficulty">Difficulty</a></h3>
<p>The difficulty is actually determined in runtime logic, so on the client-side we use a runtime API to call into the runtime
logic and get the difficulty for the current block. More specifically, the difficulty adjustment and management occurs in the
difficulty pallet (detailed in the <code>runtime</code> section).</p>
<h3 id="verifying-a-solution"><a class="header" href="#verifying-a-solution">Verifying a Solution</a></h3>
<p>First to clarify, in our case the &quot;problem&quot; miners are solving is the following:</p>
<pre><code class="language-pseudocode">encode(arg) = SCALE encode arg to bytes
sha3(bytes) = calculate sha3 hash of the given bytes
concat(a, b,...) = concatenate a, b, ...

// H256 is a 256-bit hash type, U256 is a 256-bit unsigned integer type

def do_work(difficulty: U256, pre_hash: H256, nonce: H256) -&gt; H256:
    return sha3(concat(encode(difficulty), encode(pre_hash), encode(nonce)))

def is_solution(work: H256, nonce: H256, difficulty: U256, pre_hash: H256) -&gt; bool:
    calculated = do_work(difficulty)

    // U256.MAX is the maximum value for an unsigned 256-bit integer, i.e.  2^256 - 1

    return work == calculated and U256(work) * difficulty &lt;= U256.MAX

// choose a nonce such that is_solution(do_work(difficulty, pre_hash, nonce), nonce, difficulty, pre_hash) == True
</code></pre>
<p>Given a proposed solution, we consider it valid if</p>
<ol>
<li>The hash is correct (matches the value obtained by recalculating the hash from input data)</li>
<li>The product of the hash and difficulty do not overflow a 256-bit unsigned integer. In other words <code>hash * difficulty &lt;= 2^256 - 1</code></li>
</ol>
<p>This code lives in the <a href="https://github.com/gluwa/creditcoin/tree/dev/sha3pow"><code>sha3pow</code> crate</a>.</p>
<h3 id="generating-solutions-mining"><a class="header" href="#generating-solutions-mining">Generating Solutions (Mining)</a></h3>
<p>Mining comes down to essentially picking random nonce values until you find one with the correct properties.
Once we find an appropriate nonce, we submit the solution to a <code>MiningHandle</code> which then proceeds with verification and moving forward
with publishing the block. This occurs in <a href="https://github.com/gluwa/creditcoin/tree/dev/node/src/service.rs"><code>service.rs</code></a> in the <code>creditcoin-node</code> crate.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<h2 id="what-is-a-runtime"><a class="header" href="#what-is-a-runtime">What is a runtime?</a></h2>
<p>At a high level, the runtime is the &quot;business logic&quot; of the chain.
More precisely, the runtime primarily acts as the state transition function for the blockchain. Roughly you can think of each block
as containing a set of operations to perform (transactions) and a snapshot of the state of the world after those operations
have been carried out. Then, to link a series of blocks together each block has a pointer to its predecessor.
The runtime, then, is what dictates how to actually execute those operations and how the state of the world is
modified in the process. You may also see the runtime and its components referred to as the on-chain logic. On-chain in this context means
an execution environment that can modify the state of the chain, and all modifications to state will be tracked and recorded.</p>
<h2 id="how-is-the-runtime-organized"><a class="header" href="#how-is-the-runtime-organized">How is the runtime organized?</a></h2>
<p>Substrate (which creditcoin builds on) uses the FRAME framework to define independent modules (called <em>pallets</em>)
which can be composed to build up the runtime. So, for instance, you might have a <a href="https://github.com/paritytech/substrate/tree/master/frame/balances">pallet</a>
which maintains balances for a set of accounts and provides operations on those balances (transfer funds, deposit funds, withdrawals, etc.).</p>
<p>The <code>creditcoin-node-runtime</code> crate (found in the <code>runtime</code> directory) is where we glue together all of the pieces of on-chain logic, and
basically consists of configuring all of the pallets we use and incorporating them into the runtime.</p>
<p>For each pallet, you'll probably have a <code>Config</code> trait which allows pallets to be generic over certain types
that can be configured at the runtime level. For instance, here is where we decide that block numbers are
represented by a <code>u32</code> and balances by a <code>u128</code>. For each pallet the runtime has to implement the <code>Config</code> trait.</p>
<p>Some pallets also define runtime APIs. For the most part you can ignore these, but for context runtime APIs are essentially an interface
for the outer node/client to call into the runtime. So, for instance, if you wanted to expose an RPC that needed some information from the runtime,
you would define a runtime API, implement the logic in the runtime, and then call your runtime API from the RPC handler.</p>
<p>Pretty much the entirety of the runtime is in <a href="https://github.com/gluwa/creditcoin/tree/dev/runtime/src/lib.rs"><code>lib.rs</code></a>. If you need to increase the runtime version
(required after non-backwards-compatible changes to the runtime, i.e. any consensus-affecting change) that's in <a href="https://github.com/gluwa/creditcoin/tree/dev/runtime/src/version.rs"><code>version.rs</code></a></p>
<h2 id="what-pallets-do-we-use"><a class="header" href="#what-pallets-do-we-use">What pallets do we use?</a></h2>
<p>A bunch.</p>
<h3 id="external-pallets"><a class="header" href="#external-pallets">External Pallets</a></h3>
<p>These pallets are all part of substrate and aren't maintained by the creditcoin developers:</p>
<ul>
<li><a href="https://paritytech.github.io/substrate/master/pallet_balances/index.html">Balances</a></li>
<li><a href="https://paritytech.github.io/substrate/master/frame_system/index.html">FRAME System</a></li>
<li><a href="https://paritytech.github.io/substrate/master/pallet_scheduler/index.html">Scheduler</a></li>
<li><a href="https://paritytech.github.io/substrate/master/pallet_sudo/index.html">Sudo</a></li>
<li><a href="https://paritytech.github.io/substrate/master/pallet_timestamp/index.html">Timestamp</a></li>
<li><a href="https://paritytech.github.io/substrate/master/pallet_transaction_payment/index.html">Transaction Payment</a></li>
</ul>
<h3 id="internal-pallets"><a class="header" href="#internal-pallets">Internal Pallets</a></h3>
<p>These pallets are written and maintained by the creditcoin developers:</p>
<ul>
<li><a href="architecture/runtime/./pallet-creditcoin.html">Creditcoin</a></li>
<li><a href="architecture/runtime/pallet-difficulty.html">Difficulty</a></li>
<li><a href="https://github.com/gluwa/creditcoin/tree/dev/pallets/rewards">Rewards</a></li>
<li><a href="https://github.com/gluwa/creditcoin/tree/dev/pallets/offchain-task-scheduler">Offchain Task Scheduler</a></li>
</ul>
<p>The majority of the creditcoin developers' work is spent developing these pallets (and probably more in the future).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creditcoin-pallet"><a class="header" href="#creditcoin-pallet">Creditcoin Pallet</a></h1>
<p>The creditcoin pallet contains the logic for the loan flow (as outlined in the creditcoin whitepaper). That means
it defines all of the data structures used in the process of recording loans, it also maintains the storage
of loans and their associated data, and provides extrinsics to interact with the loan cycle. In general, each operation
in the loan cycle maps to an extrinsic, for instance registering an external address corresponds with the <code>register_address</code>
extrinsic.</p>
<p>For the most part the business logic is pretty straightforward, and isn't changed often since it's meant to adhere to the
specification of the white paper (mostly), so I won't talk too much about it. The primary exception to this is
our interactions with external blockchains.</p>
<h2 id="verifying-external-transactions"><a class="header" href="#verifying-external-transactions">Verifying External Transactions</a></h2>
<p>As part of the loan cycle, users can report a transfer of funds that occurred on a different blockchain. For instance,
Alice and Bob are in a loan where Bob leant Alice 100 ETH (Bob is a high-roller). Upon initiating the loan, Bob would
send the funds to Alice on ethereum, and then report the transfer on creditcoin to indicate he had funded the loan.
Instead of just trusting that Bob really did send 100 ETH through ethereum, we want to verify that is the case.
The idea is simple - call some ethereum RPCs to pull information about the transaction and verify that it matches
what Bob claimed. That RPC call, though, requires some extra work.</p>
<h3 id="offchain-interactions"><a class="header" href="#offchain-interactions">Offchain Interactions</a></h3>
<p>Since an RPC call requires network access, it is inherently non-deterministic. You might perform the call and get one result,
and someone else might perform the same exact call to the same exact RPC node only to receive a different result (due to transient network
errors, solar flares, bad luck, whatever else). This is bad because if we can't repeat the exact execution, it would be impossible to
replicate and verify which defeats the purpose of blockchains! Because of this, substrate disallows non-determinism in code
executing in an on-chain context. That means that the non-deterministic work needs to occur off-chain. To facilitate this pattern,
substrate provides &quot;offchain workers.&quot; Basically it's just a special function (a runtime hook, to be precise) defined by a pallet that runs on each block, and it
runs in an off-chain context. This means that code running under offchain workers can access, for instance, the network.</p>
<p>Offchain workers can freely read from on-chain storage, but they cannot write to on-chain storage. This means that the only way for
the offchain worker to communicate back to the chain is by sending transactions. The general flow for an external transfer is then</p>
<ol>
<li>Transfer registered</li>
<li>Entry put into storage indicating there's a new task to be executed</li>
<li>Offchain worker starts</li>
<li>Offchain worker looks at tasks, picks one up</li>
<li>Transfer verification occurs</li>
<li>Offchain worker sends transaction indicating the verification succeeded (or failed)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="difficulty-pallet"><a class="header" href="#difficulty-pallet">Difficulty Pallet</a></h1>
<p>The difficulty pallet is responsible for storing the difficulty of the current block, and calculating the difficulty for the next block.
The fact that this logic lives in a pallet means that we canchange our difficulty adjustment algorithm with a runtime upgrade, which is cool.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
